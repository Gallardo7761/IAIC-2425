using Pkg
Pkg.activate(".")
Pkg.instantiate()

# L√≥gica Proposicional
# ====================

## Cabecera de Carga y Librer√≠a
## ----------------------------

include("./lib/Logic.jl")

#= LEER ENTERO ANTES DE CONTINUAR
Vamos a trabajar, esencialmente, con una librer√≠a, `Satisfiability`, que permite trabajar con algunas partes de la L√≥gica Proposicional de forma c√≥moda y sencilla. Se basa en el uso de SAT solvers y SMT solvers externos (en la librer√≠a anterior, que es simplemente una carcasa personalizada sobre Satisfiability, se ha preparado para trabajar con el solver Z3). Nosotros vamos a hacer un uso limitado de todas sus capacidades, restringiendo su uso al de una calculadora l√≥gica para verificar que estamos formalizando correctamente y comprobar la satisfactibilidad, consecuencia l√≥gica, pasar a forma clausal/normal, algoritmo DPLL, etc.

##    Sobre Z3 y su instalaci√≥n

    Instalar Z3 es muy sencillo, basta bajarse la versi√≥n correspondiente al SO de: https://github.com/Z3Prover/z3/releases/tag/z3-4.13.0. Tras ello, se descomprime en una carpeta (yo la he puesto en c:/utils/z3), y ya est√° listo para funcionar. 

    Normalmente, bastar√≠a con a√±adir al path de las variables de entorno de tu SO la direcci√≥n en la que se encuentra el ejecutable para que se pueda ejecutar desde cualquier proceso por medio del comando simple `z3`, pero como aqu√≠ estamos ejecut√°ndolo dentro de un REPL dentro de VSCode, pueden aparecer algunos problemas de localizaci√≥n.

    En la √∫ltima versi√≥n de `Satisfiability`, la primera ejecuci√≥n de la librer√≠a reconoce si Z3 est√° instalado y, en caso negativo, se encarga de su instalaci√≥n en segundo plano. En todo caso, esta opci√≥n debe ser estudiada para ver que funciona en todos los casos.
=#

# Tras este par√©ntesis, podemos hacer un recorrido muy r√°pido sobre lo poco que necesitamos para poder hacer algunos ejercicios de representaci√≥n en L√≥gica Proposicional:

# La declaraci√≥n de variables booleanas (variables proposicionales) se hace por medio de una macro, por ejemplo:

@satvariable(p, Bool)
@satvariable(q, Bool)
@satvariable(r, Bool)

# Tambi√©n permite declarar Arrays de variables booleanas:

@satvariable(z[1:3], Bool)

# que podemos usar directamente, o "desestructurar", facilitando la escritura cuando son muchas variables:

a, b, c = z

# La definici√≥n de f√≥rmulas m√°s complejas se puede hacer por medio sint√°ctico, funcional, o una mezcla de ambos:

f1 = ((p ‚üπ q) ‚àß (q ‚üπ r)) ‚ü∫ (p ‚üπ r)
f2 = iff((p ‚üπ q) ‚àß (q ‚üπ r), p ‚üπ r)
f3 = iff(and(implies(p,q), implies(q,r)), (implies(p,r)))

# La funci√≥n `SAT` ejecuta el solver sobre la f√≥rmula deseada, devolviendo (true / false) y, en caso de que sea satisfactible, almacena en las variables proposicionales los valores que la hacen satisfactible:

SAT(f1)
println("p = $(value(p)), q = $(value(q)), r = $(value(r))")

SAT(¬¨f1)
println("p = $(value(p)), q = $(value(q)), r = $(value(r))")

# Disponemos tambi√©n de las funciones habituales INSAT, TAUT y EQUIV para decidir si una f√≥rmula es insatisfactible, tautolog√≠a, o saber si dos f√≥rmulas son equivalentes. Incluso, trabajando con colecciones de  f√≥rmulas, podemos responder al problema de la consecuencia l√≥gica, CONS (o ‚ãâ si se quiere usar de forma infija). Por ejemplo:

EQUIV(f1, f2)
EQUIV(f1, f3)
TAUT(f1)
TAUT(p ‚à® ¬¨p)
INSAT(p ‚àß ¬¨p)

println(tree(f1))

begin
    @satvariable(z[1:3], Bool)
    a,b,c = z
    @show [a ‚àß b] ‚ãâ a;
    @show CONS([a ‚àß b], a);
    @show [a ‚à® b] ‚ãâ a;
    @show [a ‚üπ b, b] ‚ãâ a;
    @show [a ‚üπ b, a] ‚ãâ b;
    @show CONS([a ‚üπ b, a], b);
end

## Uso extendido de L√≥gica Proposicional dentro de Julia

    # Ten en cuenta que esto nos permite incluir una capa de L√≥gica Proposicional dentro de Julia que es capaz de considerar valores booleanos sobre variables proposicionales qe internamente usan cualquier tipo de dato, por ejemplo:

    @satvariable(a[1:6], Int)
    c = [215; 275; 335; 355; 420; 580]

    expr = (and(a .>= 0)) ‚àß (sum(a .* c) == 1770)
    SAT(expr)
    println("Resultado: $(value(a))")
    println("Comprobaci√≥n: $(sum(value(a) .* c))")

    expr2 = (and(a .>= 0)) ‚àß (sum(a .* c) == 1770) ‚àß (a[5] > 0)
    SAT(expr2)
    println("Resultado: $(value(a))")
    println("Comprobaci√≥n: $(sum(value(a) .* c))")

    # O incluso hacer comprobaciones a nivel de funciones. Por ejemplo
    @satvariable(x, Bool)
    @satvariable(y, Bool)
    @uninterpreted(f, Bool, Bool)
    SAT([x != y, f(x) == y, f(f(x)) == x])
    @show f(true);
    @show f(false);

# -----------------------------------------------------------------------------
# Demostraci√≥n de utiliadades de la librer√≠a
# -----------------------------------------------------------------------------

# La siguiente funci√≥n sirve de demostraci√≥n de uso de algunas otras
# funcionalidades que pueden encontrarse en la librer√≠a desarrollada para el 
# curso

# Demo de varias funcionalidades
function demoLP(f, var)
    clc();
    cr = Crayon(foreground=:blue,bold=true)
    cn = Crayon(foreground=:white,bold=false)
    println(cr, "√Årbol de Formaci√≥n de: ", cn,"$(pretty(f))",cn)
    println(tree(f))
    println(cr, "Subf√≥rmulas:", cn)
    sf = subform(f)
    for f in sf
        println("  $(pretty(f)), Prof. = $(depth(f))")
    end
    println()

    cnf_f, disyunciones_f = CNF(f)
    println(cr, "FNC:  ",cn,"$(pretty(cnf_f))")
    println(cr, "EQUIV(FNC(f),f)", cn, " = $(EQUIV(cnf_f,f))")
    println(cr, "Cl√°usulas:", cn)
    dis = pretty.(disyunciones_f)
    for f in dis    
        println("   $f")
    end

    lit = reduce(vcat,literals.(disyunciones_f))
    println(cr, "Literales", cn, " = $lit")

    println(cr, "Forma Clausal:", cn, " $(clausal_form(f))")
    println()
    
    println(cr, "Modelos:", cn)
    sol = models(f, var)
    for (i,s) in enumerate(sol)
        sol10 = join(["$v: $(x ? 1 : 0)" for (v,x) in s], ", ")  # Representaci√≥n -> 0/1
        println("   m_$i = {$sol10}")                            # La mostramos
    end

    println()
    println(cr, "DPLL (completo):", cn)
    DPLL(f; debug=true)
    println()
    println(cr, "DPLL (soluciones):", cn)
    DPLL(f; debug=false)
end 

@satvariable(p,Bool)
@satvariable(q,Bool)
@satvariable(r,Bool)
@satvariable(s,Bool)
@satvariable(t,Bool)

demoLP(¬¨p ‚à® q, [p,q])
demoLP(p ‚àß q, [p,q])
demoLP((¬¨p ‚üπ q) ‚üπ r ‚àß s, [p,q,r,s])
demoLP((p ‚à® q) ‚üπ (¬¨r ‚àß t ‚àß s), [p,q,r,s,t])
demoLP(((p ‚à® q) ‚üπ (¬¨r ‚àß t ‚àß s)) ‚àß ((¬¨r ‚àß t ‚àß s) ‚üπ (p ‚à® q)), [p,q,r,s,t])


# -----------------------------------------------------------------------------
# Ejemplos Resueltos
# -----------------------------------------------------------------------------

# En los ejemplos siguientes, si no se dice lo contrario, habr√° que formalizar el razonamiento en una L√≥gica Proposicional con las variables adecuadas y verificar si el razonamiento es v√°lido o no haciendo uso de las funciones definidas anteriormente.

#= 
Ejemplo 1
---------

Si Juan es comunista, entonces Juan es ateo. Juan es ateo. Por tanto, Juan es comunista.

Definimos las siguientes variables proposicionales:

    1.  c : Juan es comunista
    2.  a : Juan es ateo

=#

clc();
@satvariable(c, Bool)                 # üëÄ declaraci√≥n de variables booleanas
@satvariable(a, Bool)

# Por la definici√≥n de Tautolog√≠a:
TAUT(((c ‚üπ a) ‚àß a ) ‚üπ c)
println("   c = $(value(c)),  a = $(value(a))")

# Por reducci√≥n al absurdo:
INSAT(and([c ‚üπ a,a,¬¨c]))
println("   c = $(value(c)),  a = $(value(a))")

# Por la funci√≥n de consecuencia l√≥gica:
@show [c ‚üπ a,a] ‚ãâ c
println("   c = $(value(c)),  a = $(value(a))")

#= 
Ejemplo 2
---------

Cuando tanto la temperatura como la presi√≥n atmosf√©rica permanecen contantes, no llueve. La temperatura permanece constante. En consecuencia, en caso de que llueva, la presi√≥n atmosf√©rica no permanece constante.

Definimos las siguientes variables proposicionales:

    1.  T : Temperatura permanece constante
    2.  P : Presi√≥n permanece constante
    3.  L : Llueve 
=#

clc();
@satvariable(T, Bool)
@satvariable(P, Bool)
@satvariable(L, Bool)
@show [(T ‚àß P) ‚üπ ¬¨ L, T] ‚ãâ (L ‚üπ ¬¨ P)

#= 
Ejemplo 3
---------

Siempre que un n√∫mero x es divisible por 10, acaba en 0. El n√∫mero x no acaba en 0. Luego, x no es divisible por 10.

Definimos las siguientes variables proposicionales:

    1.  d10 : x es divisible por 10
    2.  a0 : x acaba en 0
=#

clc();
@satvariable(d10, Bool)
@satvariable(a0, Bool)
@show [d10 ‚üπ a0, ¬¨a0] ‚ãâ ¬¨d10


#= 
Ejemplo 4
---------

En un texto de Lewis Carroll, el tio Jorge y el t√≠o Jaime discuten acerca de la barber√≠a del pueblo, atendida por tres barberos: Alberto, Benito y Carlos. Los dos t√≠os aceptan las siguientes premisas:

    1. Si Carlos no est√° en la barber√≠a, entonces ocurrir√° que si tampoco est√° Alberto, Benito tendr√° que estar para atender el establecimiento.
    2. Si Alberto no est√°, tampoco estar√° Benito.
    
El t√≠o Jorge concluye de todo esto que Carlos no puede estar ausente, mientras que el t√≠o Jaime afirma que s√≥lo puede concluirse que Carlos y Alberto no pueden estar ausentes a la vez. 

¬øCu√°l de los dos tiene raz√≥n?

Definimos las siguientes variables proposicionales:

    1.  A : Alberto est√° en la barber√≠a
    2.  B : Benito est√° en la barber√≠a
    3.  C : Carlos est√° en la barber√≠a 
=#

clc();
@satvariable(z[1:3],Bool)
A,B,C = z
Hechos = [¬¨C ‚üπ (¬¨A ‚üπ B), ¬¨A ‚üπ ¬¨B]
Jorge = Hechos ‚ãâ C
Jaime = Hechos ‚ãâ ¬¨(¬¨C ‚àß ¬¨A)
@show Jorge;
@show Jaime;

#= 
Ejemplo 5
---------

Demuestra la correcci√≥n del siguiente argumento.

    1. Los animales con pelo o que dan leche son mam√≠feros.
    2. Los mam√≠feros que tienen pezu√±as o que rumian son ungulados.
    3. Los ungulados de cuello largo son jirafas.
    4. Los ungulados con rayas negras son cebras.

Se observa un animal que tiene pelos, pezu√±as y rayas negras. Por tanto, el animal es una cebra.

Definimos las siguientes variables proposicionales:

    1.  P : Animal con pelo
    2.  L : Animal que da leche
    3.  M : Mam√≠fero
    4.  Z : Pezu√±as
    5.  R : Rumian
    6.  U : Ungulado
    7.  C : Cuello largo
    8.  J : Jirafa
    9.  N : Rayas negras
    10. Cb : Cebra 
=#

@satvariable(z[1:10], Bool)
P, L, M, Z, R, U, C, J, N, Cb = z
Hechos = [(P ‚à® L) ‚üπ M, (M ‚àß (Z ‚à® R)) ‚üπ U, (U ‚àß C) ‚üπ J, (U ‚àß N) ‚üπ Cb, P, Z, N]
@show Hechos ‚ãâ Cb


#= 
Ejemplo 6
---------

Problema de las N Reinas...

=#

N = 8

# Usaremos una variable proposicional para cada posici√≥n del tablero, indicando si hay una reina o no. As√≠, a partir de ahora, si se verifica r[i,j] significa que en la posici√≥n (i,j) del trablero hay una reina.
@satvariable(r[1:N,1:N], Bool)

# 1. En cada fila hay como mucho una reina: Si r(i.j) entonces no puede verificarse ning√∫n otro r(i,j¬¥)

Filas(N) = [ r[i,j]‚üπ ¬¨r[i,j¬¥] for i in 1:N for j in 1:N for j¬¥ in 1:N if j ‚â† j¬¥]

# 2. En cada columna hay como mucho una reina: Si r(i.j) entonces no puede verificarse ning√∫n otro r(i¬¥,j)

Columnas(N) = [ r[i,j]‚üπ ¬¨r[i¬¥,j] for i in 1:N for j in 1:N for i¬¥ in 1:N if i ‚â† i¬¥]

# 3. En cada diagonal principal hay como mucho una reina: Si r(i,j) entonces no puede verificarse ning√∫n otro r(i+k,j+k)

DiagonalPrincipal(N) = [ r[i,j]‚üπ ¬¨r[i+k,j+k] for i in 1:N for j in 1:N for k in -N:N if (k ‚â† 0) && (i+k ‚àà 1:N) && (j+k ‚àà 1:N)]

# 3. En cada diagonal secundaria hay como mucho una reina: Si r(i,j) entonces no puede verificarse ning√∫n otro r(i+k,j-k)

DiagonalSecundaria(N) = [ r[i,j]‚üπ ¬¨r[i+k,j-k] for i in 1:N for j in 1:N for k in -N:N if (k ‚â† 0) && (i+k ‚àà 1:N) && (j-k ‚àà 1:N)]

# Todo lo anterior lo veririca, por ejemplo, el tablero vac√≠o, as√≠ que puede dar soluciones err√≥neas. Por tanto, hemos de introducir condiciones de existencia de suficientes reinas:

# 4. En cada columna hay, al menos, una reina

Marco(N) = [or(r[:,j]) for j in 1:N]

# Una distribuci√≥n de reinas ser√° soluci√≥n si verifica simult√°neamente todas las condiciones anteriores:
NReinas(N) = [Filas(N); Columnas(N); DiagonalPrincipal(N); DiagonalSecundaria(N); Marco(N)]

SAT(and(NReinas(N)))

value(r)

# Tambi√©n tenemos una funci√≥n que nos devuelve todos los modelos de una f√≥rmula. Lo que devuelve es una colecci√≥n de diccionarios en los que se indica el valor de cada variable. Adem√°s de la f√≥rmula, debes indicarle qu√© variables quieres que devuelva.

# üëÄ ¬°¬° Cuidado con la siguiente ejecuci√≥n, el n√∫mero de modelos podr√≠a ser exponencial en N !!
# üëÄ  Si quieres probarlo, reduce N a 4 o 5...
N = 5
@satvariable(r[1:N,1:N], Bool)
models(and(NReinas(N)), [r[i,j] for i in 1:N for j in 1:N])

#= 
-------------------
IMPLEMENTACI√ìN DPLL
-------------------

Este ejercicio est√° orientado a explicar la implementaci√≥n de DPLL que puedes encontrar en la librer√≠a. Para ello, haremos uso de la nomenclatura DIMACS, basada en vectores num√©ricos, y supondremos que las f√≥rmulas vienen dadas en Forma Clausal (o, equivalentemente, en Forma Normal Conjuntiva):

Si las variables que se usan son x_1,...,x_n, una cl√°usula vendr√° dada por el conjunto de √≠ndices de los literales que la forman (positivos, si el literal viene afirmado, y negativos, si el literal est√° negado). 

Representaci√≥n:
    Es decir, la representaci√≥n de la cl√°sula C ser√°:
        {i: x_i ‚àà C} ‚à™ {-i: ¬¨x_i ‚àà C}

    Lo m√°s habitual es representar $C$ como la lista/colecci√≥n/conjunto de los elementos que la forman. Por ejemplo:

        C ‚â° (x_1 ‚à® ¬¨x_3 ‚à® x_4) ‚ü∂ C ‚â° [1,-3,4]

    As√≠ pues, una f√≥rmula siempre se puede expresar como una colecci√≥n de listas de la forma anterior (que corresponde al conjunto de las cl√°usulas de su forma clausal). Por ejemplo:

        F ‚â° (p‚à®¬¨q) ‚àß (p‚à®q) ‚àß r ‚ü∂ F ‚â° [ [1,-2], [1,2], [3] ]

Algoritmo DPLL:
    Los pasos a seguir para la implementaci√≥n del algoritmo DPLL se siguen inmediatamente del modo de funcionamiento de este algoritmo:

    1. Reconocer si hay cl√°usulas unitarias (equivalentemente, listas con un solo elemento).
    2. Si hay cla√∫sulas unitarias, propagarlas, es decir: 
        1. Eliminar las cl√°usulas que contengan ese literal.
        2. Eliminar el literal complementario de las cl√°usulas que contengan el complementario.
        3. Dejar igual el resto de cl√°usulas (aquellas que no tienen ni el literal ni el complementario).
    3. Si no hay cl√°usulas unitarias, seleccionar uno de los literales que aparezcan en alguna cl√°usula y llamar dos veces al procedimiento DPLL que estamos definiendo (se forman 2 ramas de ejecuci√≥n): 
        1. Una llamada a√±adiendo una cl√°usula unitaria con el literal seleccionado. 
        2. Otra llamada a√±adiendo una cl√°usula unitaria con el literal complementario.
    4. Cuando ya no quedan cl√°usulas compuestas en una rama, podemos interpretar lo que dice esa rama:
        1. Si hay dos cla√∫sulas unitarias opuestas (una tiene un literal, y otra su complementario): esa rama no da soluci√≥n para la f√≥rmula de entrada.
        2. Si no hay cl√°usulas unitarias opuestas, entonces las cl√°usulas que quedan especifican una valoraci√≥n que es modelo de la f√≥rmula de entrada.

Observaciones
    1. DPLL es un algoritmo recursivo.
    2. En cada una las llamadas recursivas del paso 3 ya hay una cl√°usula unitaria, por lo que se ejecutar√° el paso 2 en cada una de ellas, simplificando el conjunto de cl√°usulas de nuevo.

=#


# -----------------------------------------------------------------------------
# Ejercicios Propuestos
# -----------------------------------------------------------------------------

#= 
Ejercicio 1
-----------

Haciendo uso de la librer√≠a y utilidades vistas, decide si los siguientes razonamientos son correctos:

    1. El ladr√≥n debi√≥ entrar por la puerta, a menos que el robo se perpetrara desde dentro y uno de los sirvientes estuviera implicado en √©l. Pero s√≥lo pod√≠a entrar por la puerta si alguien le descorr√≠a el cerrojo. Si alguien lo hizo, es que uno de los sirvientes estaba implicado en el robo. Luego, seguro que alg√∫n sirviente ha estado implicado.

    2. Si el tiempo est√° agradable y el cielo despejado, saldremos a navegar y nos daremos un ba√±o. No es verdad que el cielo no est√© despejado a menos que nos ba√±emos. Luego el tiempo no est√° agradable.

    3. Los salarios no suben si no aumentan los precios. No obstante, subir√°n los salarios y no los precios, a no ser que suban los salarios y simult√°neamente se produzca inflaci√≥n. Luego, en cualquier caso se producir√° inflaci√≥n.

    4. Si se elevan los precios o los salarios habr√° inflaci√≥n. Si hay inflaci√≥n, el gobierno ha de regularla o el pueblo sufrir√°. Si el pueblo sufre, los gobernantes se har√°n m√°s impopulares. Pero es as√≠ que el gobierno no regular√° la inflaci√≥n y que, sin embargo, los gobernantes no se har√°n m√°s impopulares. Entonces es que no subir√°n los salarios.

    5. La f√≠sica cu√°ntica describe la naturaleza a base de observables cl√°sicos o a base de estados abstractos. Si la describe mediante los primeros, entonces nos permite representar las cosas intuitivamente, pero nos exige renunciar a la causalidad. En cambio, si la describe mediante los segundos, nos impide la representaci√≥n intuitiva, pero nos permite conservar la causalidad. La f√≠sica cu√°ntica nos permitir√° representar las cosas intuitivamente, a no ser que nos exija renunciar a la causalidad. Por tanto, no es cierto que nos permita representar las cosas intuitivamente s√≥lo si no renuncia a la causalidad. 
=#


#= 
Ejercicio 2
-----------

A partir del algoritmo DPLL implementado, define funciones que decidan SAT, TAUT, equivalencia entre f√≥rmulas y Consecuencia L√≥gica. Para diferenciarlas de las funciones que vienen en la propia librer√≠a ponles como nombre: SAT-DPLL, INSAT-DPLL, TAUT-DPLL, EQUIV-DPLL y CONS-DPLL.
=#

#= 
Ejercicio 3
-----------

Aplica DPLL para resolver los siguientes problemas (se recomienda hacer los ejercicios a mano y despu√©s comprobar que son correctos usando la nomeclatura en vectores num√©ricos y usando la funci√≥n DPLL explicada anteriormente):

1. Determina la consistencia de los siguientes conjuntos de cl√°usulas:

    {p ‚à® ¬¨q, p ‚à® q, ¬¨p ‚à® ¬¨q, ¬¨p ‚à® q}
    {¬¨r, q, p ‚à® ¬¨q, ¬¨p ‚à® r}
    {p ‚à® q ‚à® r, ¬¨p ‚à® q, ¬¨q ‚à® r, ¬¨r, p ‚à® r}
    {p, ¬¨p ‚à® q, r}
    {¬¨p ‚à® ¬¨q ‚à® r, ¬¨s ‚à® t, ¬¨t ‚à® p, s, ¬¨s ‚à® u, ¬¨u ‚à® q, ¬¨r}
    {p ‚à® q, q ‚à® r, r ‚à® w, ¬¨r ‚à® ¬¨p, ¬¨w ‚à® ¬¨q, ¬¨q ‚à® ¬¨r}
    {¬¨p ‚à® ¬¨q ‚à® r, ¬¨p ‚à® ¬¨t ‚à® u, ¬¨p ‚à® ¬¨u ‚à® s, ¬¨t ‚à® q, t, p, ¬¨s}

2. Decide la verdad o falsedad de las siguientes afirmaciones:

    {p ‚üπ (q ‚üπ r), r ‚üπ q} ‚ä® r ‚ü∫ q
    {p ‚üπ q, q ‚üπ (p ‚àß q), p ‚üπ r} ‚ä® q ‚üπ r  
=#

#= 
Ejercicio 4
-----------

Las guerras clon han comenzado. Durante el transcurso de una refriega, tres caballeros Jedi, Anakin, Obi Wan y Yoda, se encuentran con el conde Dooku. Utilizaremos el lenguaje proposicional A, O, Y para denotar que el correspondiente caballero participa en el combate, y G para denotar que los Jedi han ganado.

1. Formaliza las siguientes afirmaciones:

    F_1: Para derrotar al conde Dooku deben participar al menos dos caballeros Jedi.
    F_2: El Conde Dooku gana cuando s√≥lo participa un caballero.
    F_3: Si el Conde Dooku pierde entonces Anakin ha participado en el combate.
    F_4: Si el Conde Dooku pierde, entonces no han participado los tres caballeros.

2. ¬øEs cierto que {F_1,F_2,F_3} ‚ä® G‚ÜíA‚àßO? 
=#

#= 
Ejercicio 5
-----------

En una isla habitan dos tribus de nativos, A y B. Todos los miembros de la tribu A siempre dicen la verdad, mientras que todos los de la tribu B siempre mienten. Llegamos a esta isla y le preguntamos a un nativo si all√≠ hay oro, a lo que nos responde: 

    Hay oro en la isla si y s√≥lo si yo siempre digo la verdad.

A partir de lo que nos han dicho:
    1. ¬øPodemos saber si hay oro en la isla?
    2. ¬øPodemos determinar a qu√© tribu pertenece el nativo que nos respondi√≥? 
=#

#= 
Ejercicio 6
-----------

Tres ni√±os, Manolito, Juanito y Jesuli, son sorprendidos despu√©s de haberse roto el cristal de una ventana cerca de donde estaban jugando. Al preguntarles si alguno de ellos lo hab√≠a roto, respondieron lo siguiente:

    Manolito: Juanito lo hizo, Jesuli es inocente.
    Juanito: Si Manolito lo rompi√≥, entonces Jesuli es inocente.
    Jesuli: Yo no lo hice, pero uno de los otros dos s√≠ lo rompi√≥.

1. ¬øSon consistentes las afirmaciones anteriores? 
2. Si se comprueba que ninguno de los ni√±os rompi√≥ el cristal, ¬øqui√©nes han mentido?
3. Si se asume que todos dicen la verdad, ¬øqui√©n rompi√≥ el cristal? 
=#